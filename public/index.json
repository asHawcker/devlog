[{"content":"\rHome/Projects/Custom Memory Allocators/Absolutely Naive Allocator\rNaive Memory Allocator\rI implemented the basic allocator implementation mentioned in the article mentioned previously.\nThis is a basic functional allocator. There are a few problems, I can directly figure that we would face.\nfreeing is O(n). so as we allocate more and more memory, we will take longer to free the blocks. incase all blocks except the last one are freed and then we free the last one, programbreak is only moved till the end of this last block only. all the already allocated headers still exist. two consecutive free headers may be sufficient together but not alone, but they are checked seperately so none will be allocated and program break needs to be extended. malloc() implementation\rabsolutely-naive-allocator/alloc.c\rview raw\rfree() implementation\rabsolutely-naive-allocator/alloc.c\rview raw\rConclusion\rNow proceeding to an implicit free list allocator\n","permalink":"http://localhost:1313/projects/memory-allocator/absolutely-naive/","title":"Absolutely Naive Allocator"},{"content":"\rHome/Projects/JudgeME/Journey - JudgeME | Day 1\rJourney\rDay 1\rThe Initial Idea\rI had this Idea from a youtube video I saw and I thought it would be fun to make and use. I also realised that this process is on the simpler side and I already had some Idea on how I would go about implementing this project.\nI started with looking into what tools would be necessary and suitable for implementing the idea I had. I also wanted to follow an organised folder structure and organise the code into different files depending upon the functionality.\nI did take the help of AI tools to decide on what things should be in what file and what conventions should I follow to write good readable code.\nSetting up the Github API\rThis was my first time using to the Oauth feature of Github. I set-up the Oauth app and then created the routes to call this API and then generating a JWT to save this info so I do not have to route requests to github to authorise everytime the LogIn button is clicked.\nThis reduces the constant need to call github and also saves up time of repeated users. I also learned how passport-gihub made this so much easy. I proceeded with setting up the GeminiAPI and a minimal frontend to test the API. I spend some time testing out different prompts to find what works best.\nOne thing that helped was increasing the temperature of the model from 1 to 1.2. This allowed the model to be a little more \u0026ldquo;creative\u0026rdquo;, which was good for the quircky response that I was expecting the model to produce. Frontend\rI now upgraded the frontend and I decided to go with a dark neon-ish Arch linux inspired theme.\n","permalink":"http://localhost:1313/projects/judgeme/journey-d1/","title":"Journey - JudgeME | Day 1"},{"content":"\rHome/Projects/Process Checkpointing - xv6/System Design - xv6 checkpointing\rSystem Design\rThe checkpoint image format\rThe checkpoint-ed process is stored as a binary image file with a specific structure. To ensure data integrity, a header containing metadata is written at the beginning of the file, followed by the raw memory dump. The structure of the file is visualized in Figure 1. The header acts as a metadata container, ensuring that the restoration process has all context required (PID, memory size, and CPU registers) before it begins loading the raw memory data.\nThe corresponding C structure definition used in the kernel is shown below:\n# define CHECKPOINT_HEADER_ID 0 xDEADBEEF struct check_point_header { uint id ; // Magic number (0 xDEADBEEF ) int pid ; // Original Process ID uint sz ; // Size of process memory in bytes char name [16]; // Process name struct trapframe tf ; // Saved CPU registers }; System Calls\rTwo new system calls were introduced:\nint checkpoint(int pid, char *filename): Locates the target process, freezes its state, and streams its memory to disk. int restart(char *filename): Replaces the calling process’s memory and context with the data found in the image file. ","permalink":"http://localhost:1313/projects/xv6-checkpointing/system-design/","title":"System Design - xv6 checkpointing"},{"content":"\rHome/Projects/Custom Memory Allocators/Implicit Freelist Allocator\rWhy \u0026ldquo;Implicit\u0026rdquo;?\rWe don\u0026rsquo;t store pointers to the next free block. The list is implied by the size in the header. To find a free block, we must visit every block (allocated or free) sequentially until we find one that fits.\nThe Architecture:\rBlock Format: Header + Payload + Footer (Boundary Tags). Traversal: Linear Scan (O(N)). Freeing: Very fast (just flip a bit). Coalescing: We will implement immediate coalescing using boundary tags. Key Characteristic: The search path includes allocated blocks. This makes malloc slow (O(N)) when the heap is full of allocated chunks.\nHEAP START HEAP END | | v v +------+ +----------------+ +------+ +----------------+ +------+ | PROL | -\u0026gt; | Allocated | -\u0026gt; | FREE | -\u0026gt; | Allocated | -\u0026gt; | EPIL | +------+ | Size: 32 | | S:48 | | Size: 16 | +------+ +----------------+ +------+ +----------------+ | Header: 32/1 | | H:48/0| | Header: 16/1 | | [ User Data ] | | [ ? ]| | [ User Data ] | | [ User Data ] | | [ ? ]| | | | Footer: 32/1 | | F:48/0| | Footer: 16/1 | +----------------+ +------+ +----------------+ ^ | ^ | | | (Must Visit) (Is Free) (Must Visit) Pros \u0026amp; Cons\rSimple: Easy to implement and debug.\nLow Overhead: Only 8 bytes overhead per block.\nSlow Allocation: $O(N)$ where $N$ is total blocks. As heap fills, malloc becomes incredibly slow.\nNo Splitting (Naive): The naive implementation wastes memory by returning the entire free block even if the user asked for a tiny slice.\nThe changes I had to adopt\rI am not using normal variables (like struct Block) because we cannot afford the memory overhead. I could use inline functions in C and the compiler would optimise them and it would work well too but here are the more reasons for using macros. Polymorphism: I don\u0026rsquo;t need to worry about input and output types with macros. This would have been an annoying and repititive task with functions. these macros act as my custom assembly like commands. Learnings\rI learned that we can\u0026rsquo;t just slice memory anywhere. You must align to 8 or 16 bytes to satisfy hardware requirements. Knuth\u0026rsquo;s Boundary Tags Trick: I learned how replicating the header at the end of the block (the Footer) allows for O(1) bidirectional traversal. This turned coalescing from a linear search problem into a constant-time operation. Now I know the problem is with traversing every block. free or not. So now I can work on that and that is exactly what the explicit freelist allocator is. ","permalink":"http://localhost:1313/projects/memory-allocator/implicit-freelist/","title":"Implicit Freelist Allocator"},{"content":"\rHome/Projects/JudgeME/Journey - JudgeME | Day 2\rJourney\rDay 2\rSetting up Chess.com\rThis was simpler than Github as no login was required here and since the entire workflow was set-up. Things went on pretty smooth. Just simple api request to fetch the user data and the gemini API worked the same.\nProblem with frontend: The frontend I made previously was not very extensible to there were a few issue to adjust it to support Chess.com judging. But I chagned it up to fit everything perfectly and to also keep it extensible for when I add new other platforms. Setting up leetcode\rI tried to include Spotify but the spotify dev platform is not allowing new app creations for sometime now so I couldn\u0026rsquo;t proceed with that. I decided to add leetcode instead. Again the process was repititive.\nMade up a different frontend feature to display the problem difficulty count to suite the theme better and to make better use of the API data recieved. ","permalink":"http://localhost:1313/projects/judgeme/journey-d2/","title":"Journey - JudgeME | Day 2"},{"content":"\rHome/Projects/Process Checkpointing - xv6/Implementations - xv6 checkpointing\rImplementation Details\rThis section details the specific code modifications required to implement the checkpointing feature.\nSystem Call Registration\rTo expose the new functionality to user space, new system calls were registered in the standard xv6 interface files.\nHeader Modifications\rIn syscall.h, unique numbers assigned to the new calls:\n#define SYS_checkpoint 22\r#define SYS_restart 23\rIn user.h, the function prototypes:\nint checkpoint (int pid , char _ filename ) ;\rint restart ( char _ filename ) ;\rIn usys.S, the entry points:\nSYSCALL ( checkpoint )\rSYSCALL ( restart )\rKernel Dispatch Table\rIn syscall.c, the sycall kernel handlers registered:\nextern int sys_checkpoint ( void ) ;\rextern int sys_restart ( void ) ;\rstatic int (\\* syscalls []) ( void ) = {\r// ... existing syscalls ...\r[ SYS_checkpoint ] sys_checkpoint ,\r[ SYS_restart ] sys_restart ,\r};\rKernel Functionality Extensions\rHelper functions were added to core kernel files to support process lookup and memory traversal.\nProcess Lookup (proc.c)\rA function was added to locate a process structure by its PID. This is essential for external checkpointing, where the target process is not the currently running one.\nstruct proc *\rfindproc (int pid )\r{\rstruct proc _ p ;\r// Iterate over ptable to find the matching PID\rfor ( p = ptable . proc ; p \u0026lt; \u0026amp; ptable . proc [ NPROC ]; p ++) {\rif(p - \u0026gt; pid == pid ) {\rreturn p ;\r}\r}\rreturn 0;\r}\rThe prototype struct proc* findproc(int); added to defs.h.\nPage Table Traversal (vm.c)\rThe walkpgdir function, normally static, is now exposed to allow sysfile.c to traverse ex- ternal page tables. This allows the checkpoint system call to read the memory of a different process. // In vm.c: Removed ’static ’ keyword\npte*t * walkpgdir ( pde*t * pgdir , const void* va , int alloc )\r{\r// ... existing implementation ...\r}\rCore Checkpointing Logic (sysfile.c)\rThe main parts of the implementation is in sysfile.c.\nMemory Copy Helper\rA helper function copy from pgdir is implemented to read memory from a target process’s page table into a kernel buffer. This handles the virtual-to-physical address translation for remote processes.\nint\rcopy_from_pgdir ( pde_t * pgdir , void * dst_k , uint src_va , uint len )\r{\ruint va = src_va ;\ruint end = src_va + len ;\rchar * d = ( char *) dst_k ;\rwhile ( va \u0026lt; end ) {\ruint va0 = ( uint ) PGROUNDDOWN ( va ) ;\rpte_t * pte = walkpgdir ( pgdir , ( void *) va0 , 0) ;\r// Check if page exists\rif( pte == 0 || (* pte \u0026amp; PTE_P ) == 0) {\rmemset (d , 0 , end - va ) ;\rbreak ;\r}\ruint pa = PTE_ADDR (* pte ) ;\ruint offset = va - va0 ;\ruint chunk = PGSIZE - offset ;\rif( chunk \u0026gt; ( end - va ) ) chunk = end - va ;\rchar *src_k = ( char *) P2V ( pa ) ; // Convert to Kernel Virtual Address\rmemmove (d , src_k + offset , chunk ) ;\rva += chunk ;\rd += chunk ;\r}\rreturn 0;\r}\rThe Checkpoint System Call\rThe sys checkpoint function handles file creation, header writing, and memory serialization. It includes logic to handle the xv6 transaction log size limit by writing data in small chunks.\nint\rsys*checkpoint ( void )\r{\rint pid ;\rchar * filename ;\rstruct proc * p ;\rstruct inode * ip ;\rstruct check_point_header hdr ;\rif( argint (0 , \u0026amp; pid ) \u0026lt; 0 || argstr (1 , \u0026amp; filename ) \u0026lt; 0) return -1;\rp = findproc ( pid ) ;\rif( p == 0) {\rcprintf (\u0026quot; Checkpoint : PID %d not found .\\n\u0026quot;, pid ) ;\rreturn -1;\r}\r// Populate Header\rhdr.id = CHECKPOINT_HEADER_ID ;\rhdr.pid = p -\u0026gt; pid ;\rhdr.sz = p -\u0026gt; sz ;\rhdr.tf = *p -\u0026gt; tf ;\rsafestrcpy ( hdr.name , p - \u0026gt; name , sizeof ( hdr . name ) ) ;\r// Create file\rbegin_op () ;\rif (( ip = create ( filename , 2 , 0 , 0) ) == 0) {\rend_op () ;\rreturn -1;\r}\rif( writei ( ip , ( char *) \u0026amp; hdr , 0 , sizeof ( hdr ) ) != sizeof ( hdr ) ) {\riunlockput ( ip ) ;\rend_op () ;\rreturn -1;\r}\rend_op () ;\r// Save Memory Loop\rint written = 0;\ruint addr = 0;\ruint size = p - \u0026gt; sz ;\rwhile ( written \u0026lt; size ) {\rint n = size - written ;\rif( n \u0026gt; 1024) n = 1024; // 1KB chunks\rchar kbuffer [1024];\r// Use efficient memmove for self , or page walker for others\rif( p == myproc () ) {\rmemmove ( kbuffer , ( void *) addr , n ) ;\r} else {\rcopy_from_pgdir (p - \u0026gt; pgdir , kbuffer , addr , n ) ;\r}\r// Write chunk in its own transaction\rbegin_op () ;\rif( writei ( ip , kbuffer , sizeof ( hdr ) + written , n ) != n ) {\rcprintf (\u0026quot; Checkpoint : write failed \\n\u0026quot;) ;\riunlockput ( ip ) ;\rend_op () ;\rreturn -1;\r}\rend_op () ;\rwritten += n ;\raddr += n ;\r}\rbegin_op () ;\riunlockput ( ip ) ;\rend_op () ;\rreturn 0;\r}\rThe Restart System Call\rThe sys restart function reads the image file, validates the magic number, resizes the current process memory, and restores the CPU state.\nint\rsys*restart ( void )\r{\rchar * path ;\rstruct inode *ip ;\rstruct check_point_header hdr ;\rstruct proc * p = myproc () ;\rif( argstr (0 , \u0026amp; path ) \u0026lt; 0) return -1;\rbegin_op () ;\rif (( ip = namei ( path ) ) == 0) {\rend_op () ;\rreturn -1;\r}\rilock ( ip ) ;\r// Read and Validate Header\rif( readi ( ip , ( char *) \u0026amp; hdr , 0 , sizeof ( hdr ) ) != sizeof ( hdr ) ) {\riunlockput ( ip ) ;\rend_op () ;\rreturn -1;\r}\rif( hdr . id != CHECKPOINT_HEADER_ID ) {\rcprintf (\u0026quot; Restart Error : Invalid Magic Number .\\n\u0026quot;) ;\riunlockput ( ip ) ;\rend_op () ;\rreturn -1;\r}\r// Resize process memory to match saved state\rif( hdr . sz \u0026gt; p - \u0026gt; sz ) {\rif (( p - \u0026gt; sz = allocuvm (p - \u0026gt; pgdir , p - \u0026gt; sz , hdr . sz ) ) == 0) {\riunlockput ( ip ) ;\rend_op () ;\rreturn -1;\r}\r} else if( hdr . sz \u0026lt; p - \u0026gt; sz ) {\rp - \u0026gt; sz = deallocuvm (p - \u0026gt; pgdir , p - \u0026gt; sz , hdr . sz ) ;\r}\r// Restore Memory Content\rint read_bytes = 0;\ruint addr = 0;\ruint size = hdr . sz ;\rwhile ( read_bytes \u0026lt; size ) {\rchar kbuffer [1024];\rint n = size - read_bytes ;\rif( n \u0026gt; sizeof ( kbuffer ) ) n = sizeof ( kbuffer ) ;\rif( readi ( ip , kbuffer , sizeof ( hdr ) + read_bytes , n ) != n ) {\rcprintf (\u0026quot; Restart : read failed \\n\u0026quot;) ;\riunlockput ( ip ) ;\rend_op () ;\rreturn -1;\r}\rmemmove (( void *) addr , kbuffer , n ) ;\rread_bytes += n ;\raddr += n ;\r}\r// Restore CPU state\r*p - \u0026gt; tf = hdr . tf ;\rp - \u0026gt; tf - \u0026gt; eax = 0; // Set return value to 0\riunlockput ( ip ) ;\rend_op () ;\rreturn 0;\r}\r","permalink":"http://localhost:1313/projects/xv6-checkpointing/implementation/","title":"Implementations - xv6 checkpointing"},{"content":"\rHome/Projects/Custom Memory Allocators/Explicit Freelist Allocator\rPlease read the Implicit Freelist Allocator first.\nWhy Upgrade to Explicit?\rThe Implicit List Bottleneck: In the implicite freelist allocator, findfit loops through every single block in the heap (allocated or free) to find a free one. Time Complexity: _O(N) where N is the total number of heap blocks. So if we have 10GB of data allocated in tiny chunks, malloc will have to scan millions of headers just to find one free slot. This is unacceptably slow.\nThe Explicit List creates a Doubly Linked List containing only the free blocks.Time Complexity: O(F) where F is the number of free blocks. If memory is full, F is small, so malloc is instant.\nArchitecture\rPayload Overlay: Free blocks store next and prev pointers inside the empty payload area. [ Header | PREV_PTR | NEXT_PTR | ... | Footer ] List Policy: LIFO - Newly freed blocks are inserted at the root of the list. Search Algorithm: First Fit on the Free List. We only scan free blocks. realloc added: Added my_realloc function which smartly extends or shrinks instead of doing malloc-copy-free We need to store next and prev pointers for our linked list. But we don\u0026rsquo;t want to waste extra RAM for them. A free block has no user data. The \u0026ldquo;Payload\u0026rdquo; area is empty. The Trick: We store the next and prev pointers inside the empty payload of the free blocks. Free blocks form a distinct Doubly Linked List. Allocated blocks are ignored during the search. The pointers (next, prev) are stored inside the empty payload of the free blocks.\nHEAP START ROOT (free_list_p) HEAP END | | | v v v +------+ +----------------+ +-------------+ +----------------+ +------+ | PROL | | Allocated | | FREE | | Allocated | | EPIL | +------+ | | | | | | +------+ +----------------+ +-------------+ +----------------+ | Header: 32/1 | | Header:48/0 | | Header: 16/1 | | [ User Data ] | | Next Ptr -----------------------------\u0026gt; NULL NULL \u0026lt;----------------------------- Prev Ptr | | [ User Data ] | | | | ... | | | | Footer: 32/1 | | Footer:48/0 | | Footer: 16/1 | +----------------+ +-------------+ +----------------+ ^ ^ ^ | | | (IGNORED) (VISITED) (IGNORED) Pros \u0026amp; Cons\rFast Allocation: O(F) where F is number of free blocks. Much faster than implicit.\nSplitting: Implemented block splitting to reduce internal fragmentation.\nComplexity: Managing list pointers during splitting and coalescing is error-prone.\nMin Block Size: Blocks must be at least 32 bytes (16 overhead + 16 pointers) to be freeable.\nBenchmarking \u0026amp; Performance\rThe project includes a performance benchmark benchmark.c designed to demonstrate the critical difference between the Implicit and Explicit allocator architectures.\nThe Workload\rThe benchmark simulates a high-load system (like a game engine or web server) by performing 50,000 random operations:\nTraffic Pattern: 60% Allocation / 40% Free (Simulates a heap that grows over time). Stress Test: Random block sizes (1 byte to 1024 bytes) to intentionally cause external fragmentation and \u0026ldquo;holes\u0026rdquo; in the heap. Metric: Measures Operations Per Second (OPS) and Total Execution Time. Performance Characteristics\rImplicit List: Performance degrades quadratically (O(N)) as the heap fills. As the number of allocated blocks increases, malloc must scan past all of them to find free space. Explicit List: Maintains high, constant throughput (O(Free)). Performance remains stable even as the heap grows to 50MB+, as malloc only traverses the dedicated list of free blocks. Next steps\rThe next obvious step would be a Segregated Freelist allocator, but it operates on the same principles. The core difference is to seperate the freelists into buckets based on size which would lead to a chained hashmap kind of structure. This is more of a debugging job, and I not much to learn in implementation as it is a minor change, still very important ofc.\nI will proceed with the Buddy and Slab Allocators.\n","permalink":"http://localhost:1313/projects/memory-allocator/explicit-freelist/","title":"Explicit Freelist Allocator"},{"content":"\rHome/Projects/JudgeME/Deployment - JudgeME | Day 3\rDeployment Day\r\u0026ldquo;Deployment is painful\u0026rdquo; - Anurag Sharma\nI started deployment on Render as I was already familiar with the process and their Free Tier is pretty generous, especially if I am not expecting much traffic. :/\nI deployed the backend and then tested with my localhost frontend if the requests are reaching the backend successfully.\nThen I moved on to deploying the frontend and the things were working fine (spoiler: they were not) I tested with chess.com and leetcode and the responses were fine.\nUntil\u0026hellip;\nSo coming to the next day, I was just playing around again with it and I logged in with github. And it was completely broken.\nI found there was a hardcoded localhost POST request in the backend. I am never using localhost URLs during developemnt ever again, only using ENV files form now on. More problems:\nAn issue arose because react-router-dom uses client-side routing, creating URLs that don\u0026rsquo;t exist on the server. Vite handles this locally but production environments throw 404 errors for unknown routes.\nSolution was to configure Render to use a Rewrite Rule. This tricks the server into sending index.html for every request. Once index.html loads, React spins up, reads the URL, and loads the correct page. With this, I am closing this project and moving on to working on other projects. This was a fun experience and taught me a lot of stuff, both technical and conventions to follow. I have a few ideas that I might add in the future like using multimodal if the request to one model fails due to GeminiAPI RPD limits.\nAny thoughts, feedback or suggestions? Mail me.\nGood-bye\n","permalink":"http://localhost:1313/projects/judgeme/journey-d3-deployment/","title":"Deployment - JudgeME | Day 3"},{"content":"\rHome/Projects/Process Checkpointing - xv6/Usage Manual - xv6 checkpointing\rUsage Manual\rThis section provides instructions on how to use the implemented system calls in user-space programs.\nCreating a Checkpoint\rUse the checkpoint(int pid, char *filename) system call.\npid: The Process ID of the target process to save. Use getpid() for self-checkpointing. filename: The name of the file to be created (e.g., ”backup.img”). Returns: 0 on success, -1 on failure. Restoring a Process\rUse the restart(char *filename) system call.\nfilename: The path to a valid checkpoint image file. Behavior: If successful, this function does not return anything. Instead, the process memory is overwritten, and execution resumes from the saved context (the point where checkpoint was called). Inspecting an Image\rUse the imginfo command-line tool to inspect a file without loading it.\n$ imginfo save.img\r=== Checkpoint Image Info ===\rFile: save.img\rStatus: VALID XV6 Checkpoint\rOrig Name: test_prog\rOrig PID: 4\rMem Size: 12288 bytes\r","permalink":"http://localhost:1313/projects/xv6-checkpointing/manual/","title":"Usage Manual - xv6 checkpointing"},{"content":"\rHome/Projects/Process Checkpointing - xv6/Challenges Faced - xv6 checkpointing\rChallenges Faced\rThe development of this feature involved overcoming several technical hurdles specific to the xv6 kernel architecture.\nFile System Transaction Limits\rThe most significant issue was the “transaction too big” kernel panic error. The xv6 journaling system has a fixed log size. I initially attempting to write the entire process memory which can exceed tens of kilobytes in a single begin op() / end op() block caused the transaction to overflow the log buffer.\nSolution: Redesigned the writing logic to perform incremental writes. Memory is serial- ized in 1KB chunks, with each chunk wrapped in its own independent transaction. This ensures that no single operation exceeds the journal’s capacity.\nCross-Process Memory Access\rStandard kernel functions like copyin and memmove are designed to operate on the current process’s page table. When checkpointing an external process (e.g., PID 4 saving PID 5), these functions fail because they cannot resolve the virtual addresses of the target process.\nSolution: I exposed the walkpgdir function from the virtual memory subsystem. A custom copy from pgdir helper is implemented to manually walk the target process’s page directory, resolve virtual addresses to physical addresses, and map them to kernel space for reading.\nHeader Dependency Conflicts\rImplementing the check point header structure required access to struct trapframe. However, including x86.h in sysfile.c caused circular dependency errors with other kernel headers.\nSolution: The necessary structures (struct trapframe) were manually defined locally within sysfile.c, ensuring the file could compile.\nFile Descriptor Persistence\rProcesses often have open file descriptors. These refer to kernel-space objects (struct file) that are transient. Simply saving the integer file descriptor number is insufficient because the kernel object it points to will not exist upon restoration.\nSolution: The system introspects the process state before checkpointing. If open file descriptors are detected, a warning is issued to the console. Upon restoration, these descriptors are logically closed, preventing undefined behavior.\n","permalink":"http://localhost:1313/projects/xv6-checkpointing/challenges/","title":"Challenges Faced - xv6 checkpointing"},{"content":"\rAlgoviz — Algorithm Visualizer\rAug 2025\nTech Stack: React, TailwindCSS, Render\nBuilt an interactive visualization tool to help beginners understand data structures and algorithm flow. Implemented state-based execution control for step-by-step visualization. Pino — Mood Tracking Browser Extension\rAug 2025\nTech Stack: React, TailwindCSS, Manifest V3, Gemini API\nIntegrated Gemini API to generate personalized responses based on real-time mood detection. Worked with browser APIs, storage management, and extension lifecycle events to improve reliability. ","permalink":"http://localhost:1313/about/projects/","title":"Projects"},{"content":"\rIndian Institute of Information Technology, Design and Manufacturing, Kanchipuram\rB.Tech in Computer Science \u0026amp; Engineering | Chennai, India\n2023 – Present\nGPA: 8.97 / 10.00 ","permalink":"http://localhost:1313/about/education/","title":"Education"},{"content":" Programming Languages:\nFrameworks: Node.js, ExpressJS, React\nDatabases: SQL, MongoDB\nRobotics \u0026amp; ML: Scikit-Learn, ROS, SLAM, OpenCV\nTools: Git, Docker\n","permalink":"http://localhost:1313/about/tech-stack/","title":"Tech Stack"},{"content":"\rSingapore AUV Challenge 2025\rIEEE-OES Singapore Chapter | March 2025\nSecured 5th place globally among 41 on-site teams. Developed vision-based autonomy for the AUV Marco. ","permalink":"http://localhost:1313/about/competitions/","title":"Competitions"},{"content":"\rLiterati Society, IIITDM Kanchipuram\rClub Core Member \u0026amp; Ex-Coordinator\nAug 2024 – Present\nLed club events and contributed to creative writing initiatives on campus. ","permalink":"http://localhost:1313/about/volunteer/","title":"Volunteer Experience"},{"content":" Languages: Hindi (Native), English (Fluent) Interests: Robotics, Poetry ","permalink":"http://localhost:1313/about/additional/","title":"Additional Information"},{"content":"\rHome/Projects/Image Manipulation Language in C/Contributions and Learnings - IML\rMy contributions\rI mainly handled the Image processing part of the entire project wherein I wrote the Image processing functions from scratch in C (except for the canny edge detector).\nHere is the list of the functions I implemented:\nruntime.h\rview raw\rAll of the function definitions can be found in runtime.c\nMy learnings\rThrough this project I mainly got into the rabbit hole of image processing on a low-level by directly manipulating the values in the matrix.\nUnderstood how the algorithms really work and why do they work.\nUnderstood how a compiler actually works and what are the different components or stages that bring a programming language to existence.\n","permalink":"http://localhost:1313/projects/dsl-for-image-manipulation/contributions/","title":"Contributions and Learnings - IML"},{"content":"\rAUV Society – IIITDM\rSoftware Engineer (Subsystem Lead) | Chennai, India\nJun 2024 – Present\nTrained and fine-tuned YOLO models for real-time gate detection. Designed adaptive control systems and state-machine-based multithreaded Python code for AUV navigation. Integrated OAK-D camera with ROS for real-time object tracking, improving system reliability and FPS from 12 → 18. ","permalink":"http://localhost:1313/about/experience/","title":"Experience"}]